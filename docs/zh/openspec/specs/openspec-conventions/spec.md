# OpenSpec约定规范

## 目的

OpenSpec约定应定义系统能力如何记录、如何提出和跟踪变更，以及规范如何随时间演进。这个元规范作为OpenSpec自身约定的事实来源。

## 要求
### 要求：规范和变更的结构化约定

OpenSpec约定应强制使用结构化规范格式，包含清晰的要求和场景部分，以便工具可以一致地解析。

#### 场景：遵循结构化规范格式

- **当**编写或更新OpenSpec规范时
- **则**作者应使用`### 要求：...`，后跟至少一个`#### 场景：...`部分

### 要求：项目结构
OpenSpec项目应保持规范和变更的一致目录结构。

#### 场景：初始化项目结构
- **当**初始化OpenSpec项目时
- **则**它应具有此结构：
```
openspec/
├── project.md              # 项目特定上下文
├── AGENTS.md               # AI助手指令
├── specs/                  # 当前部署的能力
│   └── [capability]/       # 单一、集中的能力
│       ├── spec.md         # 什么和为什么
│       └── design.md       # 如何（可选，用于已建立的模式）
└── changes/                # 提议的变更
    ├── [change-name]/      # 描述性变更标识符
    │   ├── proposal.md     # 为什么、什么和影响
    │   ├── tasks.md        # 实现清单
    │   ├── design.md       # 技术决策（可选）
    │   └── specs/          # 完整未来状态
    │       └── [capability]/
    │           └── spec.md # 干净的markdown（无差异语法）
    └── archive/            # 已完成的变更
        └── YYYY-MM-DD-[name]/
```

### 要求：行为规范的结构化格式

行为规范应使用结构化格式，具有一致的章节标题和关键词，以确保视觉一致性和可解析性。

#### 场景：编写要求部分

- **当**在行为规范中记录要求时
- **则**使用格式为`### 要求：[名称]`的3级标题
- **并**立即跟随一个应语句描述核心行为
- **并**保持要求名称描述性且少于50个字符

#### 场景：记录场景

- **当**记录特定行为或用例时
- **则**使用格式为`#### 场景：[描述]`的4级标题
- **并**使用带粗体关键词的项目符号：
  - **给定**用于初始状态（可选）
  - **当**用于条件或触发器
  - **则**用于预期结果
  - **并**用于附加结果或条件

#### 场景：添加实现细节

- **当**步骤需要附加细节时
- **则**在主步骤下使用子项目符号
- **并**保持一致的缩进
  - 子项目符号提供示例或具体内容
  - 保持子项目符号简洁

### 要求：基于标题的要求标识

要求标题应作为当前规范和提议变更之间程序化匹配的唯一标识符。

#### 场景：程序化匹配要求

- **当**处理增量变更时
- **则**使用`### 要求：[名称]`标题作为唯一标识符
- **并**使用规范化标题：`normalize(header) = trim(header)`
- **并**在规范化后使用区分大小写的相等性比较标题

#### 场景：处理要求重命名

- **当**重命名要求时
- **则**使用特殊的`## 重命名要求`部分
- **并**明确指定旧名称和新名称：
  ```markdown
  ## 重命名要求
  - 从：`### 要求：旧名称`
  - 到：`### 要求：新名称`
  ```
- **并**如果内容也变更，在新标题下包含在已修改中

#### 场景：验证标题唯一性

- **当**创建或修改要求时
- **则**确保规范内不存在重复标题
- **并**验证工具应将重复标题标记为错误

### 要求：变更存储约定

变更提案应仅存储对规范的添加、修改和移除，而不是完整的未来状态。

#### 场景：使用添加创建变更提案

- **当**创建添加新要求的变更提案时
- **则**仅在`## 新增要求`下包含新要求
- **并**每个要求应包含其完整内容
- **并**对要求和场景使用标准结构化格式

#### 场景：使用修改创建变更提案  

- **当**创建修改现有要求的变更提案时
- **则**在`## 修改要求`下包含修改后的要求
- **并**使用与当前规范中相同的标题文本（规范化）
- **并**包含完整的修改要求（不是差异）
- **并**可选地使用内联注释如`←（曾是X）`标注变更内容

#### 场景：使用移除创建变更提案

- **当**创建移除要求的变更提案时
- **则**在`## 移除要求`下列出它们
- **并**使用规范化标题文本进行标识
- **并**包含移除原因
- **并**记录任何适用的迁移路径

`changes/[name]/specs/`目录应包含：
- 仅显示变更内容的增量文件
- 新增、修改、移除和重命名要求的部分
- 用于要求标识的规范化标题匹配
- 使用结构化格式的完整要求
- 每个要求变更类型的清晰指示

#### 场景：在CLI输出中使用标准输出符号

- **当**在CLI输出中显示增量操作时
- **则**使用这些标准符号：
  - `+`表示新增（绿色）
  - `~`表示修改（黄色）
  - `-`表示移除（红色）
  - `→`表示重命名（青色）

### 要求：归档过程增强

归档过程应使用基于标题的匹配以编程方式将增量变更应用到当前规范。

#### 场景：使用增量归档变更

- **当**归档已完成的变更时
- **则**归档命令应：
  1. 首先解析重命名部分并应用重命名
  2. 解析移除部分并通过规范化标题匹配移除
  3. 解析修改部分并通过规范化标题匹配替换（如果使用新名称）
  4. 解析新增部分并附加新要求
- **并**验证所有修改/移除标题在当前规范中存在
- **并**验证新增标题尚不存在
- **并**在main specs/目录中生成更新的规范

#### 场景：处理归档期间的冲突

- **当**增量变更与当前规范状态冲突时
- **则**归档命令应报告特定冲突
- **并**在继续之前需要手动解决
- **并**提供解决冲突的清晰指导

### 要求：提案格式

提案应使用清晰的从/到比较明确记录所有变更。

#### 场景：记录变更

- **当**记录变更内容时
- **则**提案应明确描述每个变更：

```markdown
**[部分或行为名称]**
- 从：[当前状态/要求]
- 到：[未来状态/要求]
- 原因：[为什么需要此变更]
- 影响：[重大/非重大，谁受影响]
```

这种显式格式补偿了没有内联差异的情况，并确保审查者理解将变更什么。

### 要求：变更审查

系统应支持多种审查提议变更的方法。

#### 场景：审查变更

- **当**审查提议变更时
- **则**审查者可以使用：
- 提交变更时的GitHub PR差异视图
- 命令行：`diff -u specs/[capability]/spec.md changes/[name]/specs/[capability]/spec.md`
- 比较当前与未来状态的任何视觉差异工具

系统依赖于工具生成差异，而不是存储它们。

## 能力命名

能力应使用：
- 动词-名词模式（例如，`user-auth`、`payment-capture`）
- 连字符小写名称
- 单一焦点（每个能力一个职责）
- 无嵌套（`specs/`下的扁平结构）

## 何时需要提案

应为以下情况创建提案：
- 新功能或能力
- 对现有行为的重大变更
- 架构或模式变更
- 改变行为的性能优化
- 影响访问模式的安全更新

不需要提案的情况：
- 恢复预期行为的错误修复
- 拼写错误或格式修复
- 非重大依赖项更新
- 为现有行为添加测试
- 文档澄清

## 为什么采用这种方法

干净的未来状态存储提供：
- **可读性**：无差异语法污染
- **AI兼容性**：AI工具理解的标准markdown
- **简单性**：无需特殊解析或处理
- **工具无关**：任何差异工具都可以显示变更
- **清晰意图**：显式提案记录推理

结构化格式添加：
- **视觉一致性**：要求和场景前缀使部分立即可识别
- **可解析性**：一致的结构支持工具和自动化
- **逐步采用**：现有规范可以逐步迁移