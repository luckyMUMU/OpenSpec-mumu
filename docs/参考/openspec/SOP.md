# OpenSpec AI 项目工作流规范 (v1.0)

基于 OpenSpec 代码库设计的 AI 辅助开发标准作业程序

**核心：准度 > 速度。** 严禁跳步，重复失败立即熔断。  
**原则：规范先行，渐进披露。** 先变更文档（标记变更），再修改代码。

---

## 1. 基础约束

* **沟通**：全中文交流，代码注释含中文说明。
* **环境**：Windows 系统，命令兼容 PowerShell。
* **原则**：准确重于速度；高内聚低耦合；严禁 `unwrap/expect`。
* **规范**：遵循 OpenSpec 的构件图（Artifact Graph）工作流模式。

---

## 2. OpenSpec 工作流核心概念

### 2.1 构件图（Artifact Graph）

OpenSpec 采用构件驱动的开发模式，每个变更包含四个核心构件：

```
proposal.md → specs/ → design.md → tasks.md
     ↓           ↓         ↓         ↓
   为什么     做什么    怎么做    具体做
```

**构件说明**：
- **proposal**: 变更提案，说明为什么需要这个变更
- **specs**: 详细规范，定义系统应该做什么
- **design**: 技术设计，解释如何实现（可选）  
- **tasks**: 实施任务，列出具体的实现步骤

### 2.2 工作流状态

每个构件都有明确的状态：
- `[pending]`: 待创建
- `[in_progress]`: 进行中
- `[completed]`: 已完成

---

## 3. AI 工作流 (渐进式披露)

### 3.1 核心原则

1. **任务拆分**：按受影响模块定位 `design.md`。大任务必须以文档为维度拆分。
2. **设计先行**：修改前，在 `design.md` 创建 `## 待实现方案 (In Progress)`。
3. **内容要求**：在该区域明确 **ADR (决策记录)**、**任务清单 (Task List)**、**风险自审**。
4. **原子执行**：按清单编码。执行**渐进式重构 (Incremental Refactoring)**：修改新功能时，顺手修复同一路径下的旧代码缺陷或不规范处。
5. **归档合并**：测试通过后，将方案合并至主章节，更新 `Status` 为 `[已完成]` 并清理临时区域。

### 3.2 OpenSpec 集成要点

#### 使用 OPSX 命令
- `/opsx:new` - 创建新变更
- `/opsx:continue` - 生成下一个构件
- `/opsx:apply` - 应用任务清单
- `/opsx:archive` - 归档完成变更

#### 构件依赖管理
- 严格按照 `proposal → specs → design → tasks` 顺序
- 上游构件变更会自动标记下游构件为过时
- 支持中途中断和继续，保持状态一致性

---

## 4. 角色矩阵 (Role Matrix)

| **角色**        | **职责**               | **权限限制**               | **OpenSpec 集成** |
| ------------- | -------------------- | ---------------------- | ---------------- |
| **Router**    | 任务分诊、调度、质控。          | 全局 Read，分发指令。          | 调用 OPSX 命令，管理工作流状态 |
| **Explorer**  | 代码审计、依赖/影响面评估。       | 仅 Read (grep/ls/read)。 | 分析构件依赖关系，评估变更影响 |
| **Oracle**    | 方案对比、逻辑建模、设计文档。      | No-code (思考+Read)。     | 编写 design.md，定义技术方案 |
| **Librarian** | 维护 `.md` 索引，确保渐进式披露。 | 仅限修改 `.md` 文件。         | 更新构件文档，维护状态跟踪 |
| **Worker**    | 物理编码、测试运行、Lint 修复。   | Full-Write，受三错即停约束。    | 执行 tasks.md 中的具体任务 |

---

## 5. 标准作业程序 (SOP)

### 5.1 快速路径 (Fast Path)

**适用场景**：单文件、<30行、无逻辑变更

**流程**：
1. **分析** → 使用 `/opsx:list` 查看当前变更
2. **修改** → 直接编辑代码文件
3. **验证** → 运行测试和 Lint

### 5.2 深度路径 (Deep Path)

**适用场景**：跨文件、新功能、重构、API 变更

严格执行以下步骤：

#### 1. 审计 (Explorer)
- **定位节点**：使用代码搜索工具分析影响范围
- **分析调用链**：评估模块间依赖关系
- **评估构件影响**：确定需要更新哪些构件
- **停止点**：复述意图与影响面，待用户确认

#### 2. 设计 (Oracle)  
- **对比方案**：基于现有规范提出技术方案
- **编写 design.md**：在 `## 待实现方案 (In Progress)` 区域记录
- **更新构件状态**：标记相关构件为 `[in_progress]`
- **停止点**：`[WAITING FOR DESIGN APPROVAL]`

#### 3. 文档 (Librarian)
- **更新父级索引**：向上递归更新父级 design.md 摘要
- **同步构件状态**：确保所有相关构件状态一致
- **维护渐进披露**：保持文档层次清晰

#### 4. 执行 (Worker)
- **建立 Checkpoint**：创建代码变更检查点
- **按设计实施**：严格遵循 design.md 中的技术方案
- **运行 Lint**：确保代码质量
- **停止点**：展示 Diff 待审

#### 5. 验证 (Verify)
- **运行测试**：执行单元测试和集成测试
- **验证构件完成**：检查所有相关构件是否达到完成状态
- **成功归档**：记入完成日志，准备归档
- **失败处理**：转入第6节错误处理流程

---

## 6. 文档规范 (Documentation)

### 6.1 OpenSpec 构件文档规范

#### proposal.md 模板
```markdown
# [变更标题]

## 问题
[描述当前问题和机会]

## 解决方案
[概述解决方案]

## 影响范围
[影响的模块、API、依赖]

## 能力清单
- **新增能力**: [列出新增功能]
- **修改能力**: [列出修改的功能] 
- **移除能力**: [列出废弃的功能]
```

#### specs/[capability]/spec.md 模板
```markdown
# [能力名称] 规范

## ADDED Requirements
### Requirement: [名称]
系统必须 [功能描述]

#### Scenario: [场景名称]
- **WHEN** [触发条件]
- **THEN** [预期结果]

## MODIFIED Requirements
[修改的需求，包含完整内容]

## REMOVED Requirements  
### Requirement: [旧功能名称]
**Reason**: [移除原因]
**Migration**: [迁移路径]
```

#### design.md 模板
```markdown
# 模块：[名称]

## 1. 核心定义 (Stable)
### 1.1 领域模型
[实体、值对象定义]

### 1.2 接口定义
[公开接口 Trait/Struct]

### 1.3 依赖关系
[模块依赖图]

## 2. 待实现方案 (In Progress) 🟢
### 2.1 决策记录 (ADR)
- **决策**: [技术选型决策]
- **理由**: [选择理由]  
- **风险**: [潜在风险]

### 2.2 任务清单
- [ ] Task 0: 渐进式重构 (修复相关旧逻辑/格式)
- [ ] Task 1: [具体任务1]

### 2.3 接口契约
```rust
// 伪代码定义
pub trait NewFeature {
    fn method(&self) -> Result<()>;
}
```

## 3. 状态记录
- `[进行中]` | [描述] | [日期]
- `[已完成]` | [历史清单]
```

### 6.2 目录层级规范

| 目录 | 用途 | 变更策略 | OpenSpec 集成 |
|------|------|----------|---------------|
| `docs/` | 项目级设计文档 | 遵循渐进式披露架构 | 作为 proposal 参考 |
| `docs/参考/` | AI 工作流参考文档 | **非明确指出不变更**，作为规约基准 | 工作流标准依据 |
| `src/**/design.md` | 模块级设计文档 | 按本规约第2节执行 | 与 tasks.md 关联 |
| `openspec/changes/*/` | 变更构件存储 | 通过 OPSX 命令管理 | 核心工作流载体 |

### 6.3 通用原则

- **结构**: 根目录 (大图景) -> 模块级 (职责/接口) -> 叶子级 (实现细节)
- **原则**: 父目录仅保留子目录简介及链接，严禁展开细节  
- **渐进披露**: 
  1. 先标记文档变更（`[进行中]`）
  2. 再实施代码修改
  3. 测试通过后归档（`[已完成]`）

---

## 7. 三错即停机制 (3-Strike Rule)

1. **Strike 1**: 分析报错，执行逻辑修正。
2. **Strike 2**: 停止编码。Explorer 审计环境，Oracle 微调方案，二次修复。
3. **Strike 3 (熔断)**: 停止工具调用，生成 `FAILURE_REPORT.md`（含方案回放、瓶颈推论），锁定权限等待人工干预。

**OpenSpec 特殊处理**：
- 构件验证失败时，自动标记相关构件为 `[error]` 状态
- 生成错误报告时包含构件依赖图状态
- 支持从任意构件重新启动工作流

---

## 8. 技术规范

* **解耦**：严禁逆向依赖，跨模块调用必须走公开接口/Trait。
* **构件一致性**：确保 proposal → specs → design → tasks 的逻辑一致性。
* **健壮性**：具体异常捕获 + `Tracing` 分级日志。资源必须在所有分支安全释放。
* **性能**：关键算法标注复杂度，构件生成性能监控。
* **验证**：100% 覆盖主流程与边界条件的单元测试，包含构件状态验证。

---

## 9. AI 执行指令

> **任务开始时，AI 必须回复：**
> 1. 受影响模块及任务拆分计划。
> 2. 展示 `design.md` 中的"待实现方案"及任务清单。
> 3. 评估需要创建/更新的 OpenSpec 构件。
> 4. 风险自审完成后，请求用户确认以开始编码。

**OpenSpec 特定检查项**：
- 当前活跃的变更列表（`/opsx:list`）
- 相关构件的完成状态
- 是否需要创建新变更或更新现有变更
- 构件依赖关系是否清晰

---

## 10. 交互规范

- **语言**: 全中文（术语/变量除外）。
- **格式**: Markdown 强化可读性；仅复杂公式使用 LaTeX。
- **原则**: 宁慢莫错，不确定即提问。
- **OpenSpec 命令**: 使用标准 OPSX 命令格式，如 `/opsx:new`、 `/opsx:continue`。
- **构件引用**: 使用标准格式，如 `proposal.md`、`specs/user-auth/spec.md`。

---

## 附录 A: 快速参考

### 常用 OPSX 命令
```bash
# 创建新变更
/opsx:new

# 继续生成下一个构件  
/opsx:continue

# 应用任务清单
/opsx:apply

# 查看变更状态
/opsx:list

# 归档完成变更
/opsx:archive
```

### 构件状态检查
```bash
# 验证构件完整性
/opsx:validate

# 查看构件依赖图
/opsx:status
```

### 故障排除
- **构件过时**: 上游构件修改后，下游构件自动标记为过时
- **依赖冲突**: 使用 `/opsx:status` 查看依赖关系
- **状态不一致**: 使用 `/opsx:validate` 重新验证所有构件