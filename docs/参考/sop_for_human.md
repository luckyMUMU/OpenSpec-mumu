# AI 项目协作规约 - 人类阅读版

> **版本**: v1.4.0  
> **更新日期**: 2026-02-09  
> **适用对象**: 产品经理、项目经理、技术负责人、开发者

---

## 1. 什么是这套规约？

这是一套**人与 AI 协作开发**的标准工作流程。它定义了：

- **什么时候**让 AI 参与开发
- **让哪个 AI 角色**做哪部分工作
- **如何检查** AI 的工作质量
- **出了问题怎么办**

### 1.1 核心原则

| 原则 | 含义 | 为什么重要 |
|------|------|-----------|
| **准度 > 速度** | 宁可慢，也要对 | AI 犯错成本高，返工更费时 |
| **文档先行** | 先写设计文档，再写代码 | 确保理解一致，减少返工 |
| **渐进披露** | 按需获取信息，避免信息过载 | 提高决策效率 |
| **少即是多** | 先复用→改进→新建→清理 | 避免重复造轮子，保持简洁 |
| **测试独立** | 测试用例与代码分离，专人维护 | 确保测试客观性 |

### 1.2 解决什么问题？

- ✅ AI 理解偏差导致代码不符合预期
- ✅ 复杂任务拆分不清，进度难以追踪
- ✅ 代码写完了，文档没更新
- ✅ AI 连续犯错，浪费大量时间
- ✅ 测试用例受代码影响，失去客观性

---

## 2. AI 角色分工（11个角色）

把 AI 看作一个**虚拟团队**，每个角色有明确分工：

### 2.1 规划层（做决策）

| 角色 | 职责 | 权限 | 工作范围 | 人类对应角色 |
|------|------|------|----------|-------------|
| **Router** | 任务分诊、调度、质控、路径选择 | 全局读取，分发指令 | 全局 | 项目经理 |
| **Explorer** | 代码审计、依赖/影响面评估 | 仅读取（搜索/读取/分析） | 全局 | 技术负责人 |

**Router 做什么**：
- 分析任务复杂度
- 选择处理路径（快速/深度/TDD深度）
- 分配 AI 角色
- 判断是否启用TDD

**Explorer 做什么**：
- 分析代码结构
- 评估影响范围
- 识别潜在风险

---

### 2.2 需求层（挖需求）

| 角色 | 职责 | 权限 | 工作范围 | 产出物 |
|------|------|------|----------|--------|
| **Analyst** | 需求挖掘、多级PRD生成、多维度分析、原型设计 | 读取背景，写入需求文档 | 全局 | PRD/MRD/FRD/原型 |

**Analyst 做什么**：
- 通过多轮对话澄清需求
- 从业务、用户、技术、风险等多维度分析需求
- 生成结构化的多级需求文档（项目级/模块级/功能级）
- 为UI项目创建原型设计（线框图/高保真）
- 确保需求理解准确

---

### 2.3 设计层（出方案）

| 角色 | 职责 | 权限 | 工作范围 | 产出物 |
|------|------|------|----------|--------|
| **Prometheus** | 架构设计、伪代码编写、接口规范 | 架构文档读写 | 全局 | 架构设计文档 |
| **Skeptic** | 审查架构设计，发现问题和风险 | 读取架构，写入审查意见 | 全局 | 审查报告 |
| **Oracle** | 实现设计、方案对比、逻辑建模 | 实现文档读写 | 按目录 | 实现设计文档 |
| **Tester** | CSV测试用例唯一维护者 | **读写CSV（唯一）** | 按目录 | CSV测试用例 |

**区别**：
- **Analyst** = 需求分析师（了解用户想要什么）
- **Prometheus** = 建筑师（画蓝图，不考虑具体材料）
- **Skeptic** = 审查员（挑刺找问题，确保质量）
- **Oracle** = 工程师（根据蓝图做施工方案）
- **Tester** = 测试专家（基于设计生成测试用例）

**Prometheus 与 Skeptic 的协作**：
- Prometheus 设计架构 → Skeptic 审查提出问题 → Prometheus 回复修改
- 循环最多 3 轮，直到设计完善

**Tester 的独立性**：
- 仅基于设计文档生成测试用例，不参考代码实现
- CSV测试用例的唯一维护者
- 负责版本管理和变更控制

---

### 2.4 实现层（写代码）

| 角色 | 职责 | 权限 | 工作范围 | 注意 |
|------|------|------|----------|------|
| **Worker** | 物理编码、测试运行、质量检查 | 代码读写（受三错即停约束） | **design.md所在目录** | 只能按设计写，不能改设计 |
| **TestWorker** | 基于CSV编写测试代码 | **只读CSV，读写测试代码** | **design.md所在目录** | 禁止修改CSV，发现问题报告Tester |

**Worker 做什么**：
- 严格按照设计文档编写代码
- 运行测试确保质量
- 进行代码质量检查

**TestWorker 做什么**：
- 读取CSV测试用例
- 编写对应的测试代码
- 确保测试覆盖所有CSV场景
- 发现CSV问题时报告Tester（不自行修改）

**权限隔离（关键）**：
- Tester：**唯一**可以修改CSV的角色
- TestWorker：**禁止**修改CSV，只能读取

---

### 2.5 监管层（控质量）

| 角色 | 职责 | 权限 | 工作范围 | 触发时机 |
|------|------|------|----------|----------|
| **Supervisor** | 进度监管、熔断决策、并行协调 | 状态更新 + 决策触发 | 全局协调 | Worker 连续出错 3 次 |
| **Librarian** | 维护文档索引，确保渐进式披露 | 文档文件读写 | 全局 | 每个阶段完成后 |

**Supervisor 做什么**：
- 监控任务进度
- 检测异常情况
- 触发熔断机制
- 生成失败报告

**Librarian 做什么**：
- 更新文档索引
- 维护链接有效性
- 确保渐进披露结构
- 标记文档状态

---

### 2.6 角色关系图

```
Router(入口)
  ├─ 快速路径 → Explorer → Worker → Librarian
  ├─ 深度路径 → Analyst → Prometheus ↔ Skeptic → Oracle → Worker → Librarian
  └─ 目录维度路径 → Analyst → Prometheus ↔ Skeptic → Oracle → Supervisor → [多Worker并行] → Librarian
                                              ↓
                                         Supervisor(全局监管)
```

**说明**：
- **快速路径**：简单任务，单文件修改
- **深度路径**：复杂任务，单目录处理
- **目录维度路径**：复杂任务，多目录并行处理（推荐）

---

## 3. 四种工作模式

### 3.1 快速模式（简单任务）

**适用场景**：
- 单文件修改
- 小范围变更（<30行）
- 无逻辑变更（配置、文档、格式）
- 文档更新
- 配置调整

**处理流程**：
```
Explorer 分析 → Worker 修改 → Librarian 更新文档
```

**预计时间**：5-30 分钟

---

### 3.2 深度模式（复杂任务）

**适用场景**：
- 跨文件变更
- 新功能开发
- 代码重构
- API 变更
- 系统架构调整

**处理流程**：
```
新项目/大重构：
Analyst → Prometheus ↔ Skeptic → Oracle → Worker → Librarian

功能迭代：
Analyst → Oracle → Worker → Librarian
```

**说明**：
- **Analyst** 首先与用户对话，挖掘需求，生成 PRD 文档
- **Prometheus ↔ Skeptic** 是多轮审查循环，直到设计完善
- 需求确认后才进入设计和编码阶段

**预计时间**：1 天到 2 周不等

---

### 3.3 目录维度模式（推荐，多目录并行）

**适用场景**：
- 跨多个模块的复杂任务
- 大型项目重构
- 需要并行处理的复杂功能
- 多目录有依赖关系

**处理流程**：
```
Analyst → Prometheus ↔ Skeptic → Oracle → Supervisor → [多Worker并行] → Librarian
                                              ↓
                                    按目录深度调度Worker
```

**说明**：
- **Supervisor** 扫描所有design.md，按目录深度排序
- **Worker** 以design.md所在目录为工作范围
- **并行执行**：同深度无依赖的目录并行处理
- **依赖等待**：父目录等待子目录完成后才能开始
- **跨目录协调**：通过Supervisor协调跨目录变更

**目录处理顺序示例**：
```
深度3: src/core/utils/design.md      → 第一批并行
深度3: src/core/helpers/design.md    → 第一批并行
深度2: src/core/design.md            → 第二批（等待第一批）
深度2: src/api/design.md             → 第二批并行
深度1: src/design.md                 → 第三批（等待第二批）
```

**预计时间**：比标准深度模式减少30-50%（并行优势）

---

### 3.4 TDD深度模式（可选，高质量要求）

**适用场景**：
- 核心业务模块
- 复杂逻辑场景
- 需要高测试覆盖度
- 团队有TDD实践

**处理流程**：
```
Analyst → Prometheus ↔ Skeptic → Oracle → Tester → Supervisor → [多Worker并行] → Librarian
                                    ↓           ↓
                              生成CSV测试用例    实现测试代码
```

**说明**：
- **Tester** 基于设计文档生成CSV测试用例（不参考代码）
- **TestWorker** 基于CSV编写测试代码（只读CSV）
- **Worker** 按目录并行处理
- 测试用例需要人工审核
- 测试与代码并行开发

**预计时间**：比标准深度模式增加20-30%

---

## 4. 质量控制：三错即停

Worker（写代码的 AI）如果连续出错，会自动触发熔断机制：

| 阶段 | 出错次数 | 系统反应 | 人类需要做什么 |
|------|----------|----------|---------------|
| Strike 1 | 第 1 次 | 分析报错，执行修正 | 旁观 |
| Strike 2 | 第 2 次 | 停止编码，审计环境，微调方案 | 等待分析结果 |
| **Strike 3** | **第 3 次** | **熔断，停止工作，生成报告** | **必须介入决策** |

### 4.1 详细流程

**Strike 1: 初次失败**
- Worker 遇到错误或测试未通过
- 系统自动分析报错信息，定位问题，执行修正
- 建议在 30 分钟内解决

**Strike 2: 二次失败**
- Strike 1 修正后仍然失败
- 立即停止编码
- Explorer 审计环境（重新分析代码结构）
- Oracle 微调方案（调整技术方案）
- 建议在 2 小时内完成

**Strike 3: 熔断**
- Strike 2 调整后仍然失败
- Supervisor 介入，触发熔断机制
- 生成失败分析报告
- 暂停所有相关工作
- 等待用户决策

### 4.2 什么情况下会熔断？

- Worker 连续 3 次写不出正确代码
- 发现严重的架构冲突
- 测试持续失败
- 进度严重偏离预期

### 4.3 熔断后怎么办？

1. **Supervisor 生成失败报告**
   - 失败原因分析
   - 瓶颈在哪里
   - 建议的解决方案

2. **人类决策**
   - 选择建议方案继续
   - 调整需求重新设计
   - 暂停任务
   - 换其他方式实现

3. **重置后继续**
   - 错误计数清零
   - 按新方案执行

---

## 5. 关键决策点（需要人类确认）

AI 不会擅自做主，以下节点会停下来等你确认：

| 节点 | 停止点标记 | 确认内容 | 不确认会怎样 |
|------|-----------|----------|-------------|
| Analyst 完成后 | `[WAITING_FOR_REQUIREMENTS]` | 需求理解是否准确？PRD/MRD/FRD 是否完整？ | 无法进入设计阶段 |
| Prometheus 完成后 | `[WAITING_FOR_ARCHITECTURE]` | 架构设计是否合理？ | 无法进入架构审查 |
| Skeptic 完成后 | `[ARCHITECTURE_PASSED]` | 审查问题是否解决？ | 无法进入实现设计 |
| Oracle 完成后 | `[WAITING_FOR_DESIGN]` | 实现方案是否可行？ | 无法开始编码 |
| **Tester 完成后** | **`[WAITING_FOR_TEST_DESIGN]`** | **测试设计是否完整覆盖设计？** | **无法进入编码阶段** |
| Worker 完成后 | 展示 Diff | 代码是否符合预期？ | 无法提交代码 |

---

## 6. 文档分工

### 6.1 需求文档（Analyst 写）

需求文档采用**分层结构**：

| 层级 | 文档 | 位置 | 内容 | 触发条件 |
|------|------|------|------|----------|
| L1 | **Project PRD** | `docs/01_requirements/project_prd.md` | 项目愿景、目标、模块清单 | 新项目 |
| L2 | **Module MRD** | `docs/01_requirements/modules/[module]_mrd.md` | 模块功能、边界、接口 | 新模块 |
| L3 | **Feature FRD** | `docs/01_requirements/modules/[module]/[feature]_frd.md` | 功能详情、交互流程 | 新功能 |
| L3 | **Prototype** | `docs/01_requirements/prototypes/[module]/` | 界面原型（UI项目） | UI项目 |

**多维度分析包括**：
- 业务维度：业务价值、流程、规则
- 用户维度：用户画像、场景、痛点
- 功能维度：功能范围、优先级、依赖
- 技术维度：可行性、约束、集成
- 风险维度：不确定性、风险、缓解措施
- 验收维度：验收标准、成功指标

**原型设计（UI项目）**：
- **线框图**：`.drawio`, `.png` - 低保真，快速确认布局
- **高保真**：`.fig`, `.sketch`, `.xd` - 最终视觉效果
- **交互说明**：`.md` - 补充交互细节

---

### 6.2 架构设计文档（Prometheus 写）

- **位置**：`docs/02_logical_workflow/`
- **内容**：Markdown 文档（伪代码在 `pseudo` 代码块中）、接口定义、架构决策（ADR摘要）
- **特点**：技术无关，任何语言都适用
- **给谁看**：技术负责人、架构师

---

### 6.3 实现设计文档（Oracle 写）- L3

- **位置**：`src/模块/design.md`
- **内容**：具体实现方案、任务清单、技术选型
- **特点**：项目特定，可操作
- **给谁看**：开发工程师
- **层级**：L3（技术规格）

---

### 6.4 测试用例文档（Tester 写）

- **位置**：`docs/03_technical_spec/test_cases/[module]_test_cases.csv`
- **内容**：CSV格式测试用例，便于人工审核
- **特点**：
  - 仅基于设计文档，不参考代码实现
  - Tester是唯一维护者
  - 包含版本管理（版本号、更新日期）
- **给谁看**：测试人员、开发人员、产品经理

**CSV格式示例**：
```csv
# 版本: v1.0
# 更新日期: 2024-01-15
ID,模块,功能点,测试场景,前置条件,输入数据,预期输出,优先级,类型,状态,关联L2原子操作,版本,更新日期
TC001,订单,创建,正常流程,用户登录,"{product:A,qty:1}","{status:success}",P0,正向,待实现,PROCESS_ORDER,v1.0,2024-01-15
```

---

## 7. 测试独立性原则

### 7.1 为什么需要测试独立？

- **避免偏见**：测试用例不受代码实现影响
- **确保覆盖**：基于设计文档，覆盖所有逻辑分支
- **可追溯性**：测试用例与设计文档建立映射
- **版本管理**：测试用例版本与代码版本分离

### 7.2 权限隔离（关键）

| 文件 | Tester | TestWorker | 其他角色 |
|------|--------|------------|----------|
| **CSV测试用例** | **✅ 读写（唯一维护者）** | **❌ 只读** | 只读 |
| **测试代码** | 只读 | **✅ 读写（唯一维护者）** | 只读 |

### 7.3 协作流程

**正常流程**：
1. Tester 基于设计生成CSV
2. TestWorker 读取CSV编写测试代码
3. Worker 编写功能代码
4. TestWorker 运行测试

**变更流程**（当CSV需要变更时）：
1. 发现需求变更或设计变更
2. Tester 更新CSV，版本+1
3. Tester 通知 TestWorker
4. TestWorker 同步更新测试代码

**问题报告**（当TestWorker发现CSV问题时）：
1. TestWorker **禁止修改CSV**
2. TestWorker 记录问题
3. TestWorker @Tester 报告问题
4. Tester 评估并更新CSV
5. TestWorker 根据更新后的CSV调整测试代码

---

## 8. AI 技能与指令（Skill & Prompt）

### 8.1 什么是 Skill？

**Skill** 是 AI Agent 的功能模块定义，描述特定任务的完整执行逻辑。

- **存放位置**：`sop/skills/[skill-name]/SKILL.md`
- **用途**：封装角色的核心能力，可被多个角色复用
- **格式**：包含 frontmatter（name, description）的 Markdown 文件

**示例 Skill**（14个）：
- `sop-workflow-orchestrator`：工作流编排
- `sop-requirement-analyst`：需求分析
- `sop-architecture-design`：架构设计
- `sop-architecture-reviewer`：架构审查
- `sop-implementation-designer`：实现设计
- `sop-code-explorer`：代码审计
- `sop-code-implementation`：代码实现
- `sop-document-sync`：文档同步
- `sop-progress-supervisor`：进度监管
- `sop-fast-path`：快速路径
- `sop-deep-path`：深度路径
- `sop-design-placement`：设计放置
- `sop-capability-reuse`：能力复用
- `sop-tdd-workflow`：TDD工作流

---

### 8.2 什么是 Prompt？

**Prompt** 是直接给 AI Agent 的指令模板，用于激活特定角色。

- **存放位置**：`sop/prompts/[role]_prompt.md`
- **用途**：角色的"激活指令"
- **格式**：Markdown 文件，包含角色身份、职责、约束

**主要 Prompts**（11个）：
- `router_prompt.md`：激活 Router 角色
- `explorer_prompt.md`：激活 Explorer 角色
- `analyst_prompt.md`：激活 Analyst 角色
- `prometheus_prompt.md`：激活 Prometheus 角色
- `skeptic_prompt.md`：激活 Skeptic 角色
- `oracle_prompt.md`：激活 Oracle 角色
- `tester_prompt.md`：激活 Tester 角色
- `test_worker_prompt.md`：激活 TestWorker 角色
- `worker_prompt.md`：激活 Worker 角色
- `supervisor_prompt.md`：激活 Supervisor 角色
- `librarian_prompt.md`：激活 Librarian 角色

---

### 8.3 Skill vs Prompt 区别

| 特性 | Skill | Prompt |
|------|-------|--------|
| **用途** | 功能模块定义 | 角色激活指令 |
| **格式** | SKILL.md（带 frontmatter） | Markdown |
| **内容** | 完整工作流程、输入输出规范 | 角色身份、职责、约束 |
| **使用场景** | 被 AI 系统调用 | 直接发送给 AI Agent |
| **存放位置** | `skills/[name]/` | `prompts/` |
| **目标读者** | AI 系统 / 开发者 | AI Agent |

---

## 9. 快速开始指南

### 9.1 如果你是产品经理

1. **提需求时**：
   - 与 **Analyst** 对话，描述需求和目标
   - 回答 Analyst 的澄清问题
   - 提供业务背景和用户场景

2. **需求确认**：
   - 查看 **Analyst** 生成的多级需求文档（PRD/MRD/FRD）
   - 确认需求理解是否准确
   - 检查多维度分析是否完整
   - 对于UI项目，查看原型设计
   - 提出调整意见

3. **等待设计**：
   - 查看 **Prometheus** 的架构设计
   - 确认是否符合产品规划
   - 提出调整意见

4. **测试用例审核**（TDD模式）：
   - 查看 **Tester** 生成的CSV测试用例
   - 确认是否覆盖所有业务场景
   - 提出补充意见

5. **验收时**：
   - 检查 **Worker** 的代码 Diff
   - 对照 PRD 验收功能
   - 确认功能符合需求
   - 批准合并

---

### 9.2 如果你是技术负责人

1. **任务分诊**：
   - 判断用快速模式、深度模式还是TDD深度模式
   - 分配对应的 AI 角色

2. **设计审查**：
   - 审查 Prometheus 的架构设计
   - 审查 Oracle 的实现方案
   - 确保技术选型合理

3. **测试审查**（TDD模式）：
   - 审查 Tester 的CSV测试用例
   - 确认测试覆盖度
   - 确保测试独立性

4. **代码审查**：
   - 审查 Worker 的代码
   - 审查 TestWorker 的测试代码
   - 确认符合规范
   - 批准合并

5. **问题处理**：
   - 熔断时做出决策
   - 调整方案或需求

---

### 9.3 如果你是开发者

1. **查看设计**：
   - 阅读 Oracle 的实现设计文档
   - 理解技术选型和接口定义
   - 明确自己的开发任务

2. **查看测试用例**（TDD模式）：
   - 阅读 Tester 的CSV测试用例
   - 理解测试场景和预期结果
   - 确保代码满足测试要求

3. **配合 AI**：
   - 提供必要的上下文信息
   - 回答 AI 的澄清问题
   - 审查 AI 生成的代码

4. **补充完善**：
   - 添加 AI 遗漏的边界情况
   - 完善测试用例
   - 更新相关文档

---

## 10. 常见问题

### Q1: 为什么要分这么多角色？

**A**: 专业化分工，每个角色专注一件事：
- **Analyst** 专注需求（与用户对话，挖掘真实需求）
- **Prometheus** 专注架构（不考虑实现细节）
- **Skeptic** 专注审查（挑刺找问题，确保质量）
- **Oracle** 专注实现（基于架构做具体方案）
- **Tester** 专注测试用例（基于设计，不参考代码）
- **TestWorker** 专注测试代码（基于CSV用例）
- **Worker** 专注编码（不偏离设计）

这样可以提高质量，减少返工。

---

### Q2: 小改动也要走完整流程吗？

**A**: 不需要。Router 会自动判断：
- 单文件、<30 行、无逻辑变更 → 快速模式（5-30 分钟）
- 其他情况 → 深度模式
- 核心业务/复杂逻辑 → TDD深度模式（可选）

---

### Q3: 熔断是不是太严格了？

**A**: 三次机会已经很宽松了：
- 第 1 次：自动重试
- 第 2 次：重新分析
- 第 3 次：说明真的有问题，需要人类介入

这样可以避免 AI 在错误的方向上浪费大量时间。

---

### Q4: 人类需要一直盯着吗？

**A**: 不需要。AI 会在关键节点停下来等你确认，其他时间自动执行。你可以：
- 设置通知，只在需要决策时介入
- 定期查看进度报告
- 熔断时及时处理

---

### Q5: 这套规约适合什么项目？

**A**: 适合：
- 中大型项目（代码量 > 1 万行）
- 团队协作项目
- 需要长期维护的项目
- 对质量要求高的项目

不适合：
- 一次性脚本
- 个人 toy 项目
- 原型验证阶段

---

### Q6: 为什么要做测试独立？

**A**: 
- **避免偏见**：测试用例不受代码实现影响，更客观
- **确保覆盖**：基于设计文档生成，覆盖所有逻辑分支
- **可追溯性**：测试用例与设计文档建立映射，便于追溯
- **版本管理**：测试用例版本与代码版本分离，便于管理

---

### Q7: Tester 和 TestWorker 为什么不能是同一个人？

**A**: 
- **职责分离**：Tester 负责测试用例设计，TestWorker 负责测试代码实现
- **避免冲突**：如果同一个人，容易为了通过测试而修改用例
- **专业分工**：测试设计需要业务理解，测试代码需要技术能力
- **质量保障**：相互制约，确保测试质量

---

### Q8: Skill 和 Prompt 是什么？

**A**: 
- **Skill** 是 AI 的功能模块定义（如工作流编排、需求分析），面向 AI 系统
- **Prompt** 是激活 AI 角色的指令模板（如"你现在是 Analyst 角色"），面向 AI Agent

普通用户不需要关心这些，系统会自动处理。

---

## 11. 决策检查清单

### 任务开始前

- [ ] 明确需求范围和目标
- [ ] 判断用快速模式、深度模式还是TDD深度模式
- [ ] 分配对应的 AI 角色

### 需求阶段

- [ ] 与 Analyst 充分沟通需求
- [ ] 确认多级需求文档（PRD/MRD/FRD）
- [ ] 对于UI项目，确认原型设计

### 设计阶段

- [ ] 审查架构设计（Prometheus）
- [ ] 审查实现方案（Oracle）
- [ ] 确认技术选型合理
- [ ] 评估风险可控

### 测试阶段（TDD模式）

- [ ] 审查CSV测试用例（Tester）
- [ ] 确认测试覆盖度
- [ ] 确认测试独立性

### 编码阶段

- [ ] 定期查看进度报告
- [ ] 及时处理熔断情况
- [ ] 审查代码 Diff

### 完成后

- [ ] 功能验收
- [ ] 代码合并
- [ ] 文档归档

---

## 12. 快速参考

### 12.1 场景速查

| 场景 | 推荐路径 | 主要角色 | 预计时间 |
|------|----------|----------|----------|
| 修复拼写错误 | 快速路径 | Worker | 5分钟 |
| 添加日志 | 快速路径 | Worker | 10分钟 |
| 新增功能（单目录） | 深度路径 | 全角色 | 1-3天 |
| 新增功能（多目录） | 目录维度路径 | 全角色+Supervisor | 1-2天（并行加速） |
| 重构代码 | 目录维度路径 | 全角色+Supervisor | 2-4天（并行加速） |
| 架构调整 | 目录维度路径 | 全角色+Supervisor | 1-1.5周（并行加速） |
| 核心业务开发 | TDD深度路径 | 全角色+Tester+TestWorker | 1-3天+测试时间 |

### 12.2 停止点速查

| 阶段 | 停止点标记 | 等待内容 |
|------|-----------|----------|
| Analyst | `[WAITING_FOR_REQUIREMENTS]` | 用户确认PRD/MRD/FRD |
| Prometheus | `[WAITING_FOR_ARCHITECTURE]` | 架构审批 |
| Skeptic | `[ARCHITECTURE_PASSED]` | 审查通过 |
| Oracle | `[WAITING_FOR_DESIGN]` | 设计审批 |
| **Tester** | **`[WAITING_FOR_TEST_DESIGN]`** | **用户确认测试设计** |
| Worker | Diff展示 | 用户审批代码 |
| **Supervisor** | **`[SCHEDULING]`** | **目录调度完成** |
| **Worker** | **`[DIR_WORKING]`** | **目录处理中** |
| **Worker** | **`[DIR_WAITING_DEP]`** | **等待依赖目录** |
| **Worker** | **`[DIR_COMPLETED]`** | **目录处理完成** |

### 12.3 三错即停速查

| Strike | 触发条件 | 行动 | 用户干预 |
|--------|----------|------|----------|
| 1 | Worker失败 | 自动修正 | 无需 |
| 2 | 再次失败 | 审计+微调 | 等待 |
| 3 | 第三次失败 | **熔断**，生成报告 | **必须** |

### 12.4 文档层级速查

| 层级 | 文档 | 位置 | 内容 | 触发条件 |
|------|------|------|------|----------|
| L1 | Project PRD | `docs/01_requirements/project_prd.md` | 项目愿景、模块清单 | 新项目 |
| L2 | Module MRD | `docs/01_requirements/modules/[module]_mrd.md` | 模块功能、边界 | 新模块 |
| L3 | Feature FRD | `docs/01_requirements/modules/[module]/[feature]_frd.md` | 功能详情、交互 | 新功能 |
| L3 | Prototype | `docs/01_requirements/prototypes/[module]/` | 界面原型 | UI项目 |
| L4 | Implementation | `src/模块/design.md` | 实现设计、技术方案 | 编码前 |

### 12.5 测试权限速查

| 文件 | Tester | TestWorker |
|------|--------|------------|
| CSV测试用例 | **读写（唯一）** | **只读** |
| 测试代码 | 只读 | **读写（唯一）** |

---

## 13. 禁止项与约束（黑白名单）

### 13.1 核心约束

SOP 流程通过**黑白名单**明确各角色的**允许操作**（白名单）和**禁止操作**（黑名单）。

#### 五大核心约束

| 约束 | 白名单（✅ 允许） | 黑名单（❌ 禁止） | 违反后果 |
|------|------------------|------------------|----------|
| **先标记状态** | 先标记`[进行中]`，再执行操作 | 未标记状态直接修改文件 | 状态混乱，无法追踪 |
| **父目录摘要** | 父目录只保留摘要+链接 | 在父目录放置详细内容 | 破坏渐进披露结构 |
| **各角色权限** | 只操作授权范围内的文件 | 越权操作其他角色文件 | 权限混乱，数据风险 |
| **先复用** | 先复用→改进→新建→清理 | 直接新建，不复用已有 | 重复造轮子 |
| **测试独立** | 测试用例与代码分离 | 基于代码生成测试用例 | 测试偏见，失去客观性 |

### 13.2 角色特定禁止项

| 角色 | 核心禁止 | 违反后果 |
|------|----------|----------|
| **Explorer** | ❌ 修改任何代码（只读角色） | 审计失效 |
| **Tester** | ❌ 查看代码实现（保持独立） | 测试偏见 |
| **TestWorker** | ❌ 修改CSV测试用例（权限隔离） | 破坏唯一性 |
| **Worker** | ❌ 修改设计内容（除"待处理变更"外） | 设计漂移 |
| **非Librarian** | ❌ 修改`/docs/参考/`目录 | SOP标准被破坏 |

### 13.3 阶段特定禁止项

| 阶段 | 核心禁止 | 违反后果 |
|------|----------|----------|
| **需求阶段** | ❌ 开始编码 | 跳过设计，理解偏差 |
| **架构阶段** | ❌ 使用特定技术语言 | 技术绑定，失去通用性 |
| **测试用例阶段** | ❌ 参考代码实现 | 失去独立性 |
| **编码阶段** | ❌ 偏离设计文档 | 设计漂移 |

### 13.4 违反后果等级

| 等级 | 违规类型 | 处理方式 |
|------|----------|----------|
| 🟡 **轻微** | 格式不规范、链接未更新 | Librarian提醒修正 |
| 🟠 **中度** | 跳过停止点、未标记状态 | 强制停止，要求修正 |
| 🔴 **严重** | 修改SOP、破坏测试独立、3次失败 | **熔断**，人工介入 |

### 13.5 详细禁止项矩阵

完整的黑白名单定义请参考：[禁止项矩阵](sop/05_constraints/constraint_matrix.md)

相关补充规范：
- [状态字典](sop/05_constraints/state_dictionary.md)
- [安全与供应链红线](sop/05_constraints/security_supply_chain.md)

---

## 14. 分层验收机制

### 14.1 概述

分层验收机制确保每个层级的输出都经过严格检查，防止问题传递到下一层级。

### 14.2 验收角色分工

| 层级 | 验收内容 | 验收角色 | 验收方式 |
|------|----------|----------|----------|
| **L1 需求** | PRD/MRD/FRD 完整性 | Analyst + 用户 | 文档审查 |
| **L2 架构** | 伪代码、接口设计 | Skeptic | 架构审查 |
| **L3 实现** | design.md 完整性 | Oracle + Tester | 设计审查 |
| **L4 代码** | 代码实现 | Worker + 测试 | 代码审查 + 测试 |

### 14.3 各层级验收标准

#### L1 需求验收（Analyst）

**检查清单**:
- [ ] 需求覆盖所有用户场景
- [ ] 边界条件明确
- [ ] 非功能需求定义（性能、安全等）
- [ ] 原型设计完成
- [ ] 用户确认签字

**停止点**: `[WAITING_FOR_REQUIREMENTS]`

#### L2 架构验收（Skeptic）

**检查清单**:
- [ ] 架构设计符合需求
- [ ] 接口定义清晰
- [ ] 伪代码逻辑正确
- [ ] 技术选型合理
- [ ] 风险评估完成

**停止点**: `[ARCHITECTURE_PASSED]`

#### L3 实现验收（Oracle + Tester）

**检查清单**:
- [ ] 实现设计符合架构
- [ ] 技术选型细化
- [ ] 接口契约定义
- [ ] 测试用例设计完成
- [ ] 任务分解清晰

**停止点**: `[WAITING_FOR_DESIGN]`

#### L4 代码验收（Worker + 测试）

**检查清单**:
- [ ] 代码符合设计
- [ ] 单元测试通过
- [ ] 集成测试通过
- [ ] 代码审查通过
- [ ] 文档同步更新

**停止点**: Diff展示

### 14.4 测试充分性检查

#### L1-L2 阶段（测试设计）

**Tester 职责**:
- 基于设计文档生成测试用例（不参考代码）
- 覆盖正常场景、边界场景、异常场景
- 输出 CSV 格式测试用例

**验收标准**:
- [ ] 测试用例覆盖所有功能点
- [ ] 边界条件有对应测试
- [ ] 异常场景有对应测试
- [ ] 测试用例可执行

#### L3-L4 阶段（测试实现）

**TestWorker 职责**:
- 基于 CSV 测试用例编写测试代码
- 只读 CSV，不修改测试用例
- 确保测试代码与用例一致

**验收标准**:
- [ ] 所有 CSV 用例都有对应测试代码
- [ ] 测试代码可运行
- [ ] 测试通过率 100%

### 14.5 失败处理流程

```
验收失败
    ↓
标记失败原因
    ↓
返回上一阶段修正
    ↓
重新验收
    ↓
通过 → 进入下一阶段
```

**注意**: 失败 3 次触发熔断，需要人工介入。

---

## 15. 目录维度工作范围（v1.2.0新增）

### 15.1 什么是目录维度工作范围？

在 v1.2.0 版本中，我们引入了**目录维度工作范围**机制，让 Worker 以 `design.md` 所在目录为边界进行工作，实现多目录并行处理。

### 15.2 工作范围定义

**Worker 工作边界**：
```
Worker 工作范围 = design.md 所在目录及其子目录（不含嵌套 design.md 的子目录）
```

**示例**：
```
src/
├── module_a/
│   ├── design.md          ← Worker A 负责此目录
│   ├── src/               ← 可以修改
│   └── utils/             ← 可以修改
├── module_b/
│   ├── design.md          ← Worker B 负责此目录
│   └── src/               ← Worker A 不可修改
└── shared/
    └── design.md          ← Worker C 负责此目录
```

### 15.3 为什么需要目录维度？

**解决的问题**：
- ✅ 大型项目多模块并行开发效率低
- ✅ 模块间依赖关系复杂，难以协调
- ✅ 单个 Worker 处理范围过大，容易出错
- ✅ 无法充分利用并行计算能力

**带来的好处**：
- 🚀 **并行加速**：同深度无依赖目录并行处理，减少30-50%时间
- 🎯 **职责清晰**：每个 Worker 只负责一个目录，边界明确
- 🔗 **依赖可控**：通过 Supervisor 协调跨目录依赖
- 📊 **进度可视**：目录级进度追踪，问题定位更快

### 15.4 目录层级处理顺序

**处理原则**：
1. **扫描**：识别所有 design.md 文件
2. **排序**：按目录深度降序（深的先处理）
3. **并行**：同深度无依赖目录并行处理
4. **等待**：父目录等待子目录完成后才能开始

**处理顺序示例**：
```
深度3: src/core/utils/design.md      → 第一批并行（2个Worker）
深度3: src/core/helpers/design.md    → 第一批并行
深度2: src/core/design.md            → 第二批（等待第一批完成）
深度2: src/api/design.md             → 第二批并行
深度1: src/design.md                 → 第三批（等待第二批完成）
```

### 15.5 跨目录依赖处理

**原则**：Worker **不直接修改**其他目录的代码或设计内容

**处理流程**：
```
Worker A 处理 module_a/ 时发现需要修改 module_b/
    ↓
Worker A 在 module_b/design.md 中仅追加“待处理变更”条目（不得改动其他章节）
    ↓
Worker A 通知 Supervisor
    ↓
Supervisor 检查 module_b/ 状态
    ├─ 已有 Worker B → 通知 Worker B 处理
    └─ 无 Worker → 创建 Worker B
    ↓
Worker A 标记 [DIR_WAITING_DEP] 并等待
    ↓
Worker B 完成 module_b/ 的修改
    ↓
Supervisor 通知 Worker A 继续
    ↓
Worker A 完成 module_a/
```

### 15.6 Supervisor 的协调职责

**新增职责**：
- 📋 **目录映射**：维护目录-Worker 映射表
- 🚀 **并行调度**：按深度调度 Worker 并行执行
- ⏳ **依赖协调**：处理跨目录依赖等待
- 📊 **进度监控**：实时更新目录处理状态

**目录-Worker 映射表示例**：
```markdown
| 目录 | 深度 | Worker | 状态 | 依赖 |
|------|------|--------|------|------|
| src/core/utils/ | 3 | Worker-1 | [DIR_COMPLETED] | - |
| src/core/helpers/ | 3 | Worker-2 | [DIR_COMPLETED] | - |
| src/core/ | 2 | Worker-3 | [DIR_WORKING] | src/core/utils/ |
| src/api/ | 2 | Worker-4 | [DIR_WAITING_DEP] | src/core/ |
```

### 15.7 目录状态标记

| 标记 | 含义 | 使用时机 |
|------|------|----------|
| `[DIR_WORKING]` | 正在处理当前目录 | Worker 开始工作时 |
| `[DIR_WAITING_DEP]` | 等待依赖目录完成 | 遇到跨目录依赖时 |
| `[DIR_COMPLETED]` | 当前目录处理完成 | 完成所有工作时 |
| `[DIR_FAILED]` | 当前目录处理失败 | 失败无法恢复时 |
| `[SCHEDULING]` | Supervisor 正在调度 | 创建目录-Worker 映射时 |
| `[PARALLEL_EXECUTING]` | 多 Worker 并行执行中 | 同深度目录并行处理时 |

### 15.8 适用场景

**推荐使用目录维度路径**：
- ✅ 跨多个模块的新功能开发
- ✅ 大型项目代码重构
- ✅ 系统架构调整
- ✅ 多目录有依赖关系的复杂任务

**使用标准深度路径**：
- ✅ 单目录内的新功能开发
- ✅ 简单模块修改
- ✅ 独立工具函数开发

### 15.9 最佳实践

1. **合理划分目录**：按功能模块划分目录，每个目录一个 design.md
2. **明确依赖关系**：在 design.md 中声明目录依赖
3. **控制目录深度**：建议不超过 3-4 层，避免过度嵌套
4. **及时更新状态**：Worker 及时标记目录状态，便于 Supervisor 协调
5. **避免循环依赖**：设计时避免目录间循环依赖

👉 [目录维度工作策略详情](sop/04_reference/design_directory_strategy.md)

---

## 17. 参考资料与知识沉淀（v1.4.0新增）

### 17.1 为什么需要知识沉淀？

在 AI 辅助开发过程中，会接触到大量信息：
- 📄 用户提供的 PRD、设计稿、业务规则
- 🔍 网络搜索到的技术文档、最佳实践
- 📚 第三方 API 文档、开源项目参考

**如果没有妥善管理**：
- ❌ 信息散落在对话中，无法追溯
- ❌ 多次重复搜索相同内容
- ❌ 设计决策与参考资料不一致
- ❌ 团队成员无法共享知识

### 17.2 参考资料管理（RAG）

**RAG** = Retrieval Augmented Generation（检索增强生成）

**存储位置**: `docs/04_context_reference/rag/`

**目录结构**:
```
rag/
├── user_input/            # 用户提供的资料
│   ├── requirements/      # 需求文档
│   ├── designs/           # 设计稿/原型
│   └── references/        # 其他参考资料
├── external/              # 外部获取的知识
│   ├── tech_docs/         # 技术文档
│   ├── api_specs/         # API规范
│   └── best_practices/    # 最佳实践
└── project/               # 项目沉淀知识
    ├── patterns.md        # 设计模式
    ├── lessons.md         # 经验教训
    └── decisions.md       # 决策记录摘要
```

### 17.3 什么时候保存参考资料？

| 场景 | 处理方式 | 保存位置 |
|------|----------|----------|
| 用户提供需求文档 | **必须保存** | `rag/user_input/requirements/` |
| 用户提供设计稿 | **必须保存** | `rag/user_input/designs/` |
| 网络搜索技术文档 | 有价值则保存 | `rag/external/tech_docs/` |
| 查询 API 文档 | 核心接口保存 | `rag/external/api_specs/` |
| 临时问题解答 | 不保存 | - |

### 17.4 如何在设计中使用参考资料？

**架构设计阶段**（Prometheus）:
1. 检查 `rag/` 目录中的用户输入
2. 参考外部技术文档
3. 在 ADR 中引用相关文档
4. 标记 `[USER_DECISION_REQUIRED]` 如果发现冲突

**实现设计阶段**（Oracle）:
1. 查看相关的 ADR
2. 检查 `rag/` 中的技术参考
3. 在 `design.md` 中添加"参考资料"章节

**引用格式示例**:
```markdown
## 参考资料

### 架构决策 (ADR)
| ADR | 决策内容 | 状态 |
|-----|----------|------|
| [ADR-001] | 使用 PostgreSQL | 已接受 |

### 用户输入
| 来源 | 类型 | 链接 |
|------|------|------|
| [20260208_user_req] | 需求文档 | [rag/user_input/...] |

### 外部知识
| 来源 | 类型 | 链接 |
|------|------|------|
| [20260208_postgres_doc] | 技术文档 | [rag/external/...] |
```

### 17.5 冲突处理

**什么情况下会冲突？**
- ADR 决定用 MySQL，但设计选择 PostgreSQL
- 用户新需求与已接受 ADR 矛盾
- 两份参考资料建议不同的方案

**处理流程**:
```
发现冲突
    ↓
生成对比报告（冲突双方的内容和理由）
    ↓
标记 [USER_DECISION_REQUIRED]
    ↓
等待您决策
    ↓
根据决策更新设计或参考资料
```

### 17.6 最佳实践

1. **及时保存**: 收到用户资料后立即保存到 RAG
2. **规范命名**: 使用 `[YYYYMMDD]_[source]_[brief].md` 格式
3. **定期审查**: 每月检查 RAG 文件的有效性
4. **关联引用**: 在设计和 ADR 中引用相关 RAG 文件
5. **处理冲突**: 发现冲突立即标记，不要隐瞒

👉 [参考资料管理规范详情](sop/04_reference/knowledge_management.md)

---

## 附录：术语表

| 术语 | 解释 |
|------|------|
| **渐进式披露** | 信息分层展示，按需获取 |
| **伪代码** | 类似代码的文字描述，不绑定具体语言 |
| **熔断** | 停止工作，等待人工决策 |
| **ADR** | Architecture Decision Record，架构决策记录 |
| **Diff** | 代码变更对比 |
| **Skill** | AI 功能模块定义 |
| **Prompt** | AI 角色激活指令 |
| **Frontmatter** | Markdown 文件头部的元数据（如 name, description） |
| **PRD** | Product Requirements Document，产品需求文档 |
| **MRD** | Module Requirements Document，模块需求文档 |
| **FRD** | Feature Requirements Document，功能需求文档 |
| **TDD** | Test-Driven Development，测试驱动开发 |
| **CSV** | Comma-Separated Values，逗号分隔值文件格式 |
| **白名单** | 明确允许的操作清单 |
| **黑名单** | 明确禁止的操作清单 |
| **熔断** | 严重违规时停止工作，等待人工决策 |

---

## 14. 禁止项与约束（黑白名单）

### 14.1 核心约束

SOP 流程通过**黑白名单**明确各角色的**允许操作**（白名单）和**禁止操作**（黑名单）。

#### 五大核心约束

| 约束 | 白名单（✅ 允许） | 黑名单（❌ 禁止） | 违反后果 |
|------|------------------|------------------|----------|
| **先标记状态** | 先标记`[进行中]`，再执行操作 | 未标记状态直接修改文件 | 状态混乱，无法追踪 |
| **父目录摘要** | 父目录只保留摘要+链接 | 在父目录放置详细内容 | 破坏渐进披露结构 |
| **各角色权限** | 只操作授权范围内的文件 | 越权操作其他角色文件 | 权限混乱，数据风险 |
| **先复用** | 先复用→改进→新建→清理 | 直接新建，不复用已有 | 重复造轮子 |
| **测试独立** | 测试用例与代码分离 | 基于代码生成测试用例 | 测试偏见，失去客观性 |

### 14.2 角色特定禁止项

| 角色 | 核心禁止 | 违反后果 |
|------|----------|----------|
| **Explorer** | ❌ 修改任何代码（只读角色） | 审计失效 |
| **Tester** | ❌ 查看代码实现（保持独立） | 测试偏见 |
| **TestWorker** | ❌ 修改CSV测试用例（权限隔离） | 破坏唯一性 |
| **Worker** | ❌ 修改设计内容（除“待处理变更”外） | 设计漂移 |
| **非Librarian** | ❌ 修改`/docs/参考/`目录 | SOP标准被破坏 |

### 14.3 阶段特定禁止项

| 阶段 | 核心禁止 | 违反后果 |
|------|----------|----------|
| **需求阶段** | ❌ 开始编码 | 跳过设计，理解偏差 |
| **架构阶段** | ❌ 使用特定技术语言 | 技术绑定，失去通用性 |
| **测试用例阶段** | ❌ 参考代码实现 | 失去独立性 |
| **编码阶段** | ❌ 偏离设计文档 | 设计漂移 |

### 14.4 违反后果等级

| 等级 | 违规类型 | 处理方式 |
|------|----------|----------|
| 🟡 **轻微** | 格式不规范、链接未更新 | Librarian提醒修正 |
| 🟠 **中度** | 跳过停止点、未标记状态 | 强制停止，要求修正 |
| 🔴 **严重** | 修改SOP、破坏测试独立、3次失败 | **熔断**，人工介入 |

### 14.5 详细禁止项矩阵

完整的黑白名单定义请参考：[禁止项矩阵](sop/05_constraints/constraint_matrix.md)

相关补充规范：
- [状态字典](sop/05_constraints/state_dictionary.md)
- [安全与供应链红线](sop/05_constraints/security_supply_chain.md)

---

## 15. 分层验收机制

### 15.1 概述

SOP 引入**分层验收机制**，将验收分为 L1-L4 四个层级，确保代码质量逐层验证。

**核心原则**:
- **Tester 设计**: 基于 design.md 设计 L1-L4 验收测试
- **TestWorker 实现**: 实现验收测试代码
- **Worker 运行**: 仅运行测试，不创建/修改测试
- **先低后高**: 必须通过低层级，才能进行高层级
- **逐层审查**: 每层通过后必须审查

### 15.2 验收层级

| 层级 | 验收对象 | 测试类型 | 设计者 | 实现者 | 运行者 | 审查者 |
|------|----------|----------|--------|--------|--------|--------|
| **L1** | 单元/函数 | 单元测试 | Tester | TestWorker | Worker | Oracle |
| **L2** | 模块 | 集成测试 | Tester | TestWorker | Worker | Oracle |
| **L3** | 功能 | 验收测试 | Tester | TestWorker | Worker | Analyst + Oracle |
| **L4** | 系统 | E2E测试 | Tester | TestWorker | Worker | Prometheus + Analyst + Oracle |

### 15.3 验收流程

```
Worker编码完成
    ↓
检查L1测试充分性 → 不充分 → 中断询问用户
    ↓
运行L1验收测试
    ↓
L1通过 → Oracle审查
    ↓
检查L2测试充分性 → 不充分 → 中断询问用户
    ↓
运行L2验收测试
    ↓
L2通过 → Oracle审查
    ↓
检查L3测试充分性 → 不充分 → 中断询问用户
    ↓
运行L3验收测试
    ↓
L3通过 → Analyst+Oracle审查
    ↓
检查L4测试充分性 → 不充分 → 中断询问用户
    ↓
运行L4验收测试
    ↓
L4通过 → Prometheus+Analyst+Oracle审查
    ↓
全部验收通过
```

### 15.4 测试充分性检查

Worker 在运行每层验收前，必须检查：

| 检查项 | 标准 | 不充分时 |
|--------|------|----------|
| 测试设计文档存在 | `tests/acceptance/l*/[name]_test_design.md` | 中断询问 |
| 测试代码存在 | `tests/acceptance/l*/test_*.py` | 中断询问 |
| 低层级已通过 | L1通过才能进行L2 | 中断询问 |
| L1覆盖率 | >= 80% | 中断询问 |

### 15.5 审查依据

| 层级 | 审查依据 |
|------|----------|
| L1 | design.md中的接口定义 |
| L2 | design.md中的模块设计 |
| L3 | design.md中的功能设计 + FRD |
| L4 | 架构设计文档 + design.md整体设计 |

### 15.6 新增停止点

| 停止点 | 触发时机 | 等待内容 |
|--------|----------|----------|
| `[WAITING_FOR_TEST_DESIGN]` | Tester完成测试设计 | 用户确认测试设计充分 |
| `[WAITING_FOR_TEST_IMPLEMENTATION]` | TestWorker完成测试实现 | 用户确认测试实现充分 |
| `[WAITING_FOR_L1_REVIEW]` | L1测试通过后 | Oracle审查 |
| `[WAITING_FOR_L2_REVIEW]` | L2测试通过后 | Oracle审查 |
| `[WAITING_FOR_L3_REVIEW]` | L3测试通过后 | Analyst+Oracle审查 |
| `[WAITING_FOR_L4_REVIEW]` | L4测试通过后 | Prometheus+Analyst+Oracle审查 |
| `[WAITING_FOR_TEST_CREATION]` | 测试不充分时 | 用户决策 |

### 15.7 角色职责

| 角色 | 验收相关职责 | 禁止 |
|------|-------------|------|
| **Tester** | 设计L1-L4验收测试 | 实现测试代码、运行测试 |
| **TestWorker** | 实现L1-L4验收测试代码 | 设计测试、修改验收标准 |
| **Worker** | 运行L1-L4验收测试 | 创建/修改测试 |

👉 [分层验收标准详情](sop/05_constraints/acceptance_criteria.md)

---

**提示**：本文档面向人类读者，如需查看 AI 执行的详细规范，请参考 `sop/` 目录下的完整文档。
