---
version: v2.4.0
updated: 2026-02-22
---

# 编码原则（六大设计原则 + 逻辑层级一致性）

## 目的

本文件定义在创建/修改代码时必须遵守的基础编码原则，用于提升代码的可维护性、可复用性与可审查性，并为 `sop-code-review` 提供可引用的硬门槛。

---

## 六大设计原则（必须）

### 1) 单一职责原则（SRP）

- 必须：一个模块/类/方法只对一种变化原因负责。
- 禁止：把“业务决策 + 数据持久化细节 + 适配外部协议”混在同一方法中。

### 2) 开闭原则（OCP）

- 必须：新增能力优先通过扩展实现（新增实现/策略/适配器），避免修改稳定核心。
- 禁止：为新增一个业务分支频繁修改公共核心流程且无隔离点。

### 3) 里氏替换原则（LSP）

- 必须：子类型可替换父类型且不破坏语义（前置条件不更强、后置条件不更弱）。
- 禁止：子类通过抛异常/改变返回语义来“拒绝实现”父类契约。

### 4) 接口隔离原则（ISP）

- 必须：接口应小而专；调用方不应被迫依赖其不需要的方法。
- 禁止：为了“通用”而让业务方实现/依赖包含大量无关方法的臃肿接口。

### 5) 依赖倒置原则（DIP）

- 必须：高层策略/业务逻辑依赖抽象（接口/端口），低层细节（数据库/HTTP/第三方SDK）实现抽象。
- 禁止：业务逻辑直接依赖具体数据库/ORM/第三方 SDK 类型，导致替换困难。

### 6) 迪米特法则（LoD，最少知识）

- 必须：对象只与直接朋友通信；链式深层访问需要封装成有意义的方法。
- 禁止：`a.b().c().d()` 这种跨多层对象图的取数与决策混写在业务代码里。

---

## 方法逻辑层级一致性（必须）

### 规则

- 必须：一个方法内的“同层级步骤”应处于统一抽象层级（Single Level of Abstraction）。
- 必须：高层方法仅编排业务步骤；低层方法封装细节（数据访问、序列化、校验细节、第三方调用细节）。
- 禁止：在业务方法中混用“业务意图”与“底层实现细节”（例如 SQL/ORM 字段映射、事务细节、表字段赋值细节）。

### 判定方法

- 若一个方法同时出现“业务动作”（例如创建订单、变更状态、计算优惠）与“存储细节”（例如直接拼装/执行 CRUD、字段逐个赋值、SQL/ORM 查询条件细节），则判定为层级混杂。
- 若一个方法需要读/写数据表，但未复用既有 CRUD/Repository/DAO 能力，且在方法内重新实现数据访问细节，则判定为层级混杂与复用不足。

---

## CRUD 分层与复用（对表操作场景，必须）

### 分层约定

- 最底层：CRUD/DAO/Repository（对单表或明确聚合边界的持久化操作）。
- 上层：Service/UseCase/Application 层（业务决策、流程编排、跨表协作、事务边界声明）。
- 更上层：Controller/Handler（协议适配、参数解析、返回封装）。

### 复用规则

- 必须：对同一数据表的创建/更新/读取/删除优先通过已有 CRUD/Repository/DAO 方法实现。
- 必须：当存在“创建或更新”场景时，应复用最低层 CRUD 能力，并在上层编排差异规则；避免重复实现插入/更新细节。
- 禁止：业务层直接写入底层 CRUD 细节（字段映射、SQL/ORM 查询结构、连接/事务细节），导致复用困难与一致性风险。

---

## 审查要点（sop-code-review 引用）

### 🔴 阻塞项

- 业务方法出现明显抽象层级混杂，且可通过拆分/封装/复用 CRUD 消除。
- 业务逻辑直接依赖具体数据库/ORM/第三方 SDK，无法通过抽象隔离替换。

### 🟡 建议项

- 存在可明显减少“对象图深链访问”的封装机会（LoD），但短期不影响正确性。
- 可将公共分支改为策略/扩展点以满足 OCP，但当前需求仍可接受。
